@charset 'UTF-8';

//     _            _           _                           _ _
//    (_)          | |         | |                         | (_)
//     _ _ __   ___| |_   _  __| | ___   _ __ ___   ___  __| |_  __ _
//    | | '_ \ / __| | | | |/ _` |/ _ \ | '_ ` _ \ / _ \/ _` | |/ _` |
//    | | | | | (__| | |_| | (_| |  __/ | | | | | |  __/ (_| | | (_| |
//    |_|_| |_|\___|_|\__,_|\__,_|\___| |_| |_| |_|\___|\__,_|_|\__,_|
//
//      Simple, elegant and maintainable media queries in Sass
//                        v1.4.1
//
//                http://include-media.com
//
//         Authors: Eduardo Boucas (@eduardoboucas)
//                  Hugo Giraudel (@hugogiraudel)
//
//      This project is licensed under the terms of the MIT license


////
/// include-media library public configuration
/// @author Eduardo Boucas
/// @access public
////


///
/// Creates a list of global breakpoints
///
/// @example scss - Creates a single breakpoint with the label `phone`
///  $breakpoints: ('phone': 320px);
///
$breakpoints: (
				'phone': 320px,
				'tablet': 768px,
				'desktop': 1024px
) !default;


///
/// Creates a list of static expressions or media types
///
/// @example scss - Creates a single media type (screen)
///  $media-expressions: ('screen': 'screen');
///
/// @example scss - Creates a static expression with logical disjunction (OR operator)
///  $media-expressions: (
///    'retina2x': '(-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi)'
///  );
///
$media-expressions: (
				'screen': 'screen',
				'print': 'print',
				'handheld': 'handheld',
				'landscape': '(orientation: landscape)',
				'portrait': '(orientation: portrait)',
				'retina2x': '(-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi)',
				'retina3x': '(-webkit-min-device-pixel-ratio: 3), (min-resolution: 350dpi)'
) !default;


///
/// Defines a number to be added or subtracted from each unit when declaring breakpoints with exclusive intervals
///
/// @example scss - Interval for pixels is defined as `1` by default
///  @include media('>128px') {}
///
///  /* Generates: */
///  @media (min-width: 129px) {}
///
/// @example scss - Interval for ems is defined as `0.01` by default
///  @include media('>20em') {}
///
///  /* Generates: */
///  @media (min-width: 20.01em) {}
///
/// @example scss - Interval for rems is defined as `0.1` by default, to be used with `font-size: 62.5%;`
///  @include media('>2.0rem') {}
///
///  /* Generates: */
///  @media (min-width: 2.1rem) {}
///
$unit-intervals: (
				'px': 1,
				'em': 0.01,
				'rem': 0.1
) !default;

///
/// Defines whether support for media queries is available, useful for creating separate stylesheets
/// for browsers that don't support media queries.
///
/// @example scss - Disables support for media queries
///  $im-media-support: false;
///  @include media('>=tablet') {
///    .foo {
///      color: tomato;
///    }
///  }
///
///  /* Generates: */
///  .foo {
///    color: tomato;
///  }
///
$im-media-support: true !default;

///
/// Selects which breakpoint to emulate when support for media queries is disabled. Media queries that start at or
/// intercept the breakpoint will be displayed, any others will be ignored.
///
/// @example scss - This media query will show because it intercepts the static breakpoint
///  $im-media-support: false;
///  $im-no-media-breakpoint: 'desktop';
///  @include media('>=tablet') {
///    .foo {
///      color: tomato;
///    }
///  }
///
///  /* Generates: */
///  .foo {
///    color: tomato;
///  }
///
/// @example scss - This media query will NOT show because it does not intercept the desktop breakpoint
///  $im-media-support: false;
///  $im-no-media-breakpoint: 'tablet';
///  @include media('>=desktop') {
///    .foo {
///      color: tomato;
///    }
///  }
///
///  /* No output */
///
$im-no-media-breakpoint: 'desktop' !default;

///
/// Selects which media expressions are allowed in an expression for it to be used when media queries
/// are not supported.
///
/// @example scss - This media query will show because it intercepts the static breakpoint and contains only accepted media expressions
///  $im-media-support: false;
///  $im-no-media-breakpoint: 'desktop';
///  $im-no-media-expressions: ('screen');
///  @include media('>=tablet', 'screen') {
///    .foo {
///      color: tomato;
///    }
///  }
///
///   /* Generates: */
///   .foo {
///     color: tomato;
///   }
///
/// @example scss - This media query will NOT show because it intercepts the static breakpoint but contains a media expression that is not accepted
///  $im-media-support: false;
///  $im-no-media-breakpoint: 'desktop';
///  $im-no-media-expressions: ('screen');
///  @include media('>=tablet', 'retina2x') {
///    .foo {
///      color: tomato;
///    }
///  }
///
///  /* No output */
///
$im-no-media-expressions: ('screen', 'portrait', 'landscape') !default;

////
/// Cross-engine logging engine
/// @author Hugo Giraudel
/// @access private
////


///
/// Log a message either with `@error` if supported
/// else with `@warn`, using `feature-exists('at-error')`
/// to detect support.
///
/// @param {String} $message - Message to log
///
@function log($message) {
	@if feature-exists('at-error') {
		@error $message;
	} @else {
		@warn $message;
		$_: noop();
	}

	@return $message;
}


///
/// Wrapper mixin for the log function so it can be used with a more friendly
/// API than `@if log('..') {}` or `$_: log('..')`. Basically, use the function
/// within functions because it is not possible to include a mixin in a function
/// and use the mixin everywhere else because it's much more elegant.
///
/// @param {String} $message - Message to log
///
@mixin log($message) {
	@if log($message) {}
}


///
/// Function with no `@return` called next to `@warn` in Sass 3.3
/// to trigger a compiling error and stop the process.
///
@function noop() {}

///
/// Determines whether a list of conditions is intercepted by the static breakpoint.
///
/// @param {Arglist}   $conditions  - Media query conditions
///
/// @return {Boolean} - Returns true if the conditions are intercepted by the static breakpoint
///
@function im-intercepts-static-breakpoint($conditions...) {
	$no-media-breakpoint-value: map-get($breakpoints, $im-no-media-breakpoint);

	@if not $no-media-breakpoint-value {
		@if log('`#{$im-no-media-breakpoint}` is not a valid breakpoint.') {}
	}

	@each $condition in $conditions {
		@if not map-has-key($media-expressions, $condition) {
			$operator: get-expression-operator($condition);
			$prefix: get-expression-prefix($operator);
			$value: get-expression-value($condition, $operator);

			@if ($prefix == 'max' and $value <= $no-media-breakpoint-value) or
					($prefix == 'min' and $value > $no-media-breakpoint-value) {
				@return false;
			}
		} @else if not index($im-no-media-expressions, $condition) {
			@return false;
		}
	}

	@return true;
}

////
/// Parsing engine
/// @author Hugo Giraudel
/// @access private
////


///
/// Get operator of an expression
///
/// @param {String} $expression - Expression to extract operator from
///
/// @return {String} - Any of `>=`, `>`, `<=`, `<`, `≥`, `≤`
///
@function get-expression-operator($expression) {
	@each $operator in ('>=', '>', '<=', '<', '≥', '≤') {
		@if str-index($expression, $operator) {
			@return $operator;
		}
	}

	// It is not possible to include a mixin inside a function, so we have to
	// rely on the `log(..)` function rather than the `log(..)` mixin. Because
	// functions cannot be called anywhere in Sass, we need to hack the call in
	// a dummy variable, such as `$_`. If anybody ever raise a scoping issue with
	// Sass 3.3, change this line in `@if log(..) {}` instead.
	$_: log('No operator found in `#{$expression}`.');
}


///
/// Get dimension of an expression, based on a found operator
///
/// @param {String} $expression - Expression to extract dimension from
/// @param {String} $operator - Operator from `$expression`
///
/// @return {String} - `width` or `height` (or potentially anything else)
///
@function get-expression-dimension($expression, $operator) {
	$operator-index: str-index($expression, $operator);
	$parsed-dimension: str-slice($expression, 0, $operator-index - 1);
	$dimension: 'width';

	@if str-length($parsed-dimension) > 0 {
		$dimension: $parsed-dimension;
	}

	@return $dimension;
}


///
/// Get dimension prefix based on an operator
///
/// @param {String} $operator - Operator
///
/// @return {String} - `min` or `max`
///
@function get-expression-prefix($operator) {
	@return if(index(('<', '<=', '≤'), $operator), 'max', 'min');
}


///
/// Get value of an expression, based on a found operator
///
/// @param {String} $expression - Expression to extract value from
/// @param {String} $operator - Operator from `$expression`
///
/// @return {Number} - A numeric value
///
@function get-expression-value($expression, $operator) {
	$operator-index: str-index($expression, $operator);
	$value: str-slice($expression, $operator-index + str-length($operator));

	@if map-has-key($breakpoints, $value) {
		$value: map-get($breakpoints, $value);
	} @else {
		$value: to-number($value);
	}

	$interval: map-get($unit-intervals, unit($value));

	@if not $interval {
		// It is not possible to include a mixin inside a function, so we have to
		// rely on the `log(..)` function rather than the `log(..)` mixin. Because
		// functions cannot be called anywhere in Sass, we need to hack the call in
		// a dummy variable, such as `$_`. If anybody ever raise a scoping issue with
		// Sass 3.3, change this line in `@if log(..) {}` instead.
		//$_: log('Unknown unit `#{unit($value)}`.');
	}

	@if $operator == '>' {
		$value: $value + $interval;
	} @else if $operator == '<' {
		$value: $value - $interval;
	}

	@return $value;
}


///
/// Parse an expression to return a valid media-query expression
///
/// @param {String} $expression - Expression to parse
///
/// @return {String} - Valid media query
///
@function parse-expression($expression) {
	// If it is part of $media-expressions, it has no operator
	// then there is no need to go any further, just return the value
	@if map-has-key($media-expressions, $expression) {
		@return map-get($media-expressions, $expression);
	}

	$operator: get-expression-operator($expression);
	$dimension: get-expression-dimension($expression, $operator);
	$prefix: get-expression-prefix($operator);
	$value: get-expression-value($expression, $operator);

	@return '(#{$prefix}-#{$dimension}: #{$value})';
}

///
/// Slice `$list` between `$start` and `$end` indexes
///
/// @access private
///
/// @param {List} $list - List to slice
/// @param {Number} $start [1] - Start index
/// @param {Number} $end [length($list)] - End index
///
/// @return {List} Sliced list
///
@function slice($list, $start: 1, $end: length($list)) {
	@if length($list) < 1 or $start > $end {
		@return ();
	}

	$result: ();

	@for $i from $start through $end {
		$result: append($result, nth($list, $i));
	}

	@return $result;
}

////
/// String to number converter
/// @author Hugo Giraudel
/// @access private
////


///
/// Casts a string into a number
///
/// @param {String | Number} $value - Value to be parsed
///
/// @return {Number}
///
@function to-number($value) {
	@if type-of($value) == 'number' {
		@return $value;
	} @else if type-of($value) != 'string' {
		$_: log('Value for `to-number` should be a number or a string.');
	}

	$result: 0;
	$digits: 0;
	$minus: str-slice($value, 1, 1) == '-';
	$numbers: ('0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9);

	@for $i from if($minus, 2, 1) through str-length($value) {
		$character: str-slice($value, $i, $i);

		@if not (index(map-keys($numbers), $character) or $character == '.') {
			@return to-length(if($minus, -$result, $result), str-slice($value, $i))
		}

		@if $character == '.' {
			$digits: 1;
		} @else if $digits == 0 {
			$result: $result * 10 + map-get($numbers, $character);
		} @else {
			$digits: $digits * 10;
			$result: $result + map-get($numbers, $character) / $digits;
		}
	}

	@return if($minus, -$result, $result);;
}


///
/// Add `$unit` to `$value`
///
/// @param {Number} $value - Value to add unit to
/// @param {String} $unit - String representation of the unit
///
/// @return {Number} - `$value` expressed in `$unit`
///
@function to-length($value, $unit) {
	$units: ('px': 1px, 'cm': 1cm, 'mm': 1mm, '%': 1%, 'ch': 1ch, 'pc': 1pc, 'in': 1in, 'em': 1em, 'rem': 1rem, 'pt': 1pt, 'ex': 1ex, 'vw': 1vw, 'vh': 1vh, 'vmin': 1vmin, 'vmax': 1vmax);

	@if not index(map-keys($units), $unit) {
		$_: log('Invalid unit `#{$unit}`.');
	}

	@return $value * map-get($units, $unit);
}

///
/// This mixin aims at redefining the configuration just for the scope of
/// the call. It is helpful when having a component needing an extended
/// configuration such as custom breakpoints (referred to as tweakpoints)
/// for instance.
///
/// @author Hugo Giraudel
///
/// @param {Map} $tweakpoints [()] - Map of tweakpoints to be merged with `$breakpoints`
/// @param {Map} $tweak-media-expressions [()] - Map of tweaked media expressions to be merged with `$media-expression`
///
/// @example scss - Extend the global breakpoints with a tweakpoint
///  @include media-context(('custom': 678px)) {
///    .foo {
///      @include media('>phone', '<=custom') {
///       // ...
///      }
///    }
///  }
///
/// @example scss - Extend the global media expressions with a custom one
///  @include media-context($tweak-media-expressions: ('all': 'all')) {
///    .foo {
///      @include media('all', '>phone') {
///       // ...
///      }
///    }
///  }
///
/// @example scss - Extend both configuration maps
///  @include media-context(('custom': 678px), ('all': 'all')) {
///    .foo {
///      @include media('all', '>phone', '<=custom') {
///       // ...
///      }
///    }
///  }
///
@mixin media-context($tweakpoints: (), $tweak-media-expressions: ()) {
	// Save global configuration
	$global-breakpoints: $breakpoints;
	$global-media-expressions: $media-expressions;

	// Update global configuration
	$breakpoints: map-merge($breakpoints, $tweakpoints) !global;
	$media-expressions: map-merge($media-expressions, $tweak-media-expressions) !global;

	@content;

	// Restore global configuration
	$breakpoints: $global-breakpoints !global;
	$media-expressions: $tweak-media-expressions !global;
}

////
/// include-media public exposed API
/// @author Eduardo Boucas
/// @access public
////


///
/// Generates a media query based on a list of conditions
///
/// @param {Arglist}   $conditions  - Media query conditions
///
/// @example scss - With a single set breakpoint
///  @include media('>phone') { }
///
/// @example scss - With two set breakpoints
///  @include media('>phone', '<=tablet') { }
///
/// @example scss - With custom values
///  @include media('>=358px', '<850px') { }
///
/// @example scss - With set breakpoints with custom values
///  @include media('>desktop', '<=1350px') { }
///
/// @example scss - With a static expression
///  @include media('retina2x') { }
///
/// @example scss - Mixing everything
///  @include media('>=350px', '<tablet', 'retina3x') { }
///
@mixin media($conditions...) {
	@if ($im-media-support and length($conditions) == 0) or
			(not $im-media-support and im-intercepts-static-breakpoint($conditions...)) {
		@content;
	} @else if ($im-media-support and length($conditions) > 0) {
		@media #{unquote(parse-expression(nth($conditions, 1)))} {
			// Recursive call
			@include media(slice($conditions, 2)...) {
			@content;
		}
		}
	}
}


// vertical align el inside parent with fixed height/min-height
// usage
// html - .parent>.child
// scss - @include v-align;
//     or @include v-align(250px);
//     or @include v-align(250px, bottom, before);
//
@mixin v-align($va-height: 100%, $va-direction: middle, $va-pseudo: after) {
	white-space: nowrap;
	text-align: center;

	&:#{$va-pseudo} {
		content: '';
		display: inline-block;
		vertical-align: $va-direction;
		width: 0;
		min-height: $va-height;
	}

	> * {
		white-space: normal;
		display: inline-block;
		vertical-align: $va-direction;
		max-width: 100%;
	}
}

// vertical align a pair of child el inside parent
// usage
// html - .post>.image+.text
// scss - @include v-align-pair(image, text);
//     or @include v-align-pair(image, text, bottom);
//     or @include v-align-pair(image, text, middle, 200px);
//
@mixin v-align-pair($child-name1, $child-name2, $valign: middle, $width1: auto, $width2: auto ) {
	display: table;
	.#{$child-name1}{
		display: table-cell;
		vertical-align: $valign;
		width: $width1;
	}
	.#{$child-name2} {
		display: table-cell;
		vertical-align: $valign;
		width: $width2;
	}
}


// vertical align el
// usage: @include vertical-align-el;
//
@mixin vertical-align-el {
	position: relative;
	top: 50%;
	transform: translateY(-50%);
}

@mixin middle() {
	position: absolute;
	left: 50%;
	top: 50%;
	transform: translate(-50%, -50%);
}

/* mixin usage */
// .linear-gradient {
  // @include linear-gradient(#00FFFF,#0080FF,45deg);
// }

@mixin linear-gradient($color-one,$color-two,$degrees) {
  background: -moz-linear-gradient($degrees, $color-one 0%, $color-two 100%); /* ff3.6+ */
  background: -webkit-gradient(linear, left top, right top, color-stop(0%, $color-one), color-stop(100%, $color-two)); /* safari4+,chrome */
  background: -webkit-linear-gradient($degrees, $color-one 0%, $color-two 100%); /* safari5.1+,chrome10+ */
  background: -o-linear-gradient($degrees, $color-one 0%, $color-two 100%); /* opera 11.10+ */
  background: -ms-linear-gradient($degrees, $color-one 0%, $color-two 100%); /* ie10+ */
  background: linear-gradient($degrees, $color-one 0%, $color-two 100%); /* w3c */
  filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='$color-one', endColorstr='$color-two',GradientType=1 ); /* ie6-9 */
}

//
// @include rotate(rl);
//

@mixin rotate($direction: rl) {
	@if $direction == rl {
		writing-mode: sideways-rl;
		-ms-writing-mode: tb-rl;
		-webkit-writing-mode: vertical-rl;
	}
	@else {
		writing-mode: sideways-lr;
		-ms-writing-mode: tb-lr;
		-webkit-writing-mode: vertical-lr;
	}
}

/// Mixin helping defining both `width` and `height` simultaneously.
///
/// @author Hugo Giraudel
///
/// @access public
///
/// @param {Length} $width - Element’s `width`
/// @param {Length} $height ($width) - Element’s `height`
///
/// @example scss - Usage
///   .foo {
///     @include size(10em);
///   }
///
///   .bar {
///     @include size(100%, 10em);
///   }
///
/// @example css - CSS output
///   .foo {
///     width: 10em;
///     height: 10em;
///   }
///
///   .bar {
///     width: 100%;
///     height: 10em;
///   }
///
@mixin size($width, $height: $width) {
	width: $width;
	height: $height;
}

/// font-smothing
/// @include font-smoothing(on);
/// @include font-smoothing(off);
@mixin font-smoothing($value:on){
	@if $value == on{
		-webkit-font-smoothing:antialiased;
		-moz-osx-font-smoothing:grayscale;
	}
	@else{
		-webkit-font-smoothing:subpixel-antialiased;
		-moz-osx-font-smoothing:auto;
	}
}


/// Hides the text in an element, commonly used to show an image. Some elements will need block-level styles applied.
///
/// @link http://zeldman.com/2012/03/01/replacing-the-9999px-hack-new-image-replacement
///
/// @example scss - Usage
///   .element {
///     @include hide-text;
///   }
///
/// @example css - CSS Output
///   .element {
///     overflow: hidden;
///     text-indent: 101%;
///     white-space: nowrap;
///   }
///
@mixin hide-text {
	overflow: hidden;
	text-indent: 101%;
	white-space: nowrap;
}


/// Creates a visual triangle.
/// Mixin takes ($size, $color, $direction)
/// The $size argument can take one or two values—width height.
/// The $color argument can take one or two
/// values—foreground-color background-color.
///
/// @author http://bourbon.io/docs/#triangle
///
/// $direction:
/// up, down, left, right, up-right, up-left, down-right, down-left
/// @example scss - Usage
///   @include triangle(12px, gray, down);
///   @include triangle(12px 6px, gray blue, up-left);
///
@mixin triangle($size, $color, $direction) {
	$width: nth($size, 1);
	$height: nth($size, length($size));
	$foreground-color: nth($color, 1);
	$background-color: if(length($color) == 2, nth($color, 2), transparent);
	height: 0;
	width: 0;

	@if ($direction == up) or ($direction == down) or ($direction == right) or ($direction == left) {
		$width: $width / 2;
		$height: if(length($size) > 1, $height, $height/2);

		@if $direction == up {
			border-bottom: $height solid $foreground-color;
			border-left: $width solid $background-color;
			border-right: $width solid $background-color;
		} @else if $direction == right {
			border-bottom: $width solid $background-color;
			border-left: $height solid $foreground-color;
			border-top: $width solid $background-color;
		} @else if $direction == down {
			border-left: $width solid $background-color;
			border-right: $width solid $background-color;
			border-top: $height solid $foreground-color;
		} @else if $direction == left {
			border-bottom: $width solid $background-color;
			border-right: $height solid $foreground-color;
			border-top: $width solid $background-color;
		}
	} @else if ($direction == up-right) or ($direction == up-left) {
		border-top: $height solid $foreground-color;

		@if $direction == up-right {
			border-left:  $width solid $background-color;
		} @else if $direction == up-left {
			border-right: $width solid $background-color;
		}
	} @else if ($direction == down-right) or ($direction == down-left) {
		border-bottom: $height solid $foreground-color;

		@if $direction == down-right {
			border-left:  $width solid $background-color;
		} @else if $direction == down-left {
			border-right: $width solid $background-color;
		}
	} @else if ($direction == inset-up) {
		border-color: $background-color $background-color $foreground-color;
		border-style: solid;
		border-width: $height $width;
	} @else if ($direction == inset-down) {
		border-color: $foreground-color $background-color $background-color;
		border-style: solid;
		border-width: $height $width;
	} @else if ($direction == inset-right) {
		border-color: $background-color $background-color $background-color $foreground-color;
		border-style: solid;
		border-width: $width $height;
	} @else if ($direction == inset-left) {
		border-color: $background-color $foreground-color $background-color $background-color;
		border-style: solid;
		border-width: $width $height;
	}
}


/// Animate css properties
// usage
// scss - @include animate(color);
//     or @include animate(color width);
//     or @include animate(color width, 1s, linear);
//
$animation-speed: .3s !default;

@mixin animate($properties, $duration: $animation-speed, $easing: ease) {
	$list:();
	@each $prop in $properties {
		$str: #{$prop} #{$duration} #{$easing};
		$list: join($list, #{$str}, comma);
	}
	transition: $list;
}


/// Mixin for styling form-placeholders
/// @example scss - Usage
///   @include placeholder {
///    color: #333;
///   }
///
///   input[type='text'],
///   input[type='tel'],
///   input[type='email'] {
///     @include placeholder {
///      color: red;
///     }
///   }

@mixin placeholder {
	&::-webkit-input-placeholder {@content}
	&::-moz-placeholder {opacity: 1; @content}
	&:-moz-placeholder {@content}
	&:-ms-input-placeholder {@content}
	&.placeholder {@content}
}

/// Font-size px to rem calc
/// @example scss - Usage
/// selector {
///    @include rem-font-size(16px);
/// }

@mixin rem-font-size($pxSize) {
	font-size: $pxSize;
	font-size: ($pxSize / 10px) + rem;
}

//
// @include inline-grid(top);
//

@mixin inline-grid($valign: middle) {
	@extend %listreset;

	font-size: 0;

	> li {
		display: inline-block;
		vertical-align: $valign;
		font-size: 14px;
	}
}

//
// @include float-grid(33.332%, 20px);
//

@mixin float-grid($width: 50%, $space: 0) {
	@extend %clearfix;

	.col {
		float: left;
		width: calc($width - $space * 2);
		margin: 0 $space;
	}
}

//
// @include swap-order(float);
// @include swap-order(flex);
//

@mixin swap-order($prop: 'flex') {
	@if $prop == 'float' {
		@extend %clearfix;

		> .swap {
			float: left;
		}
	}
	@else {
		display: flex;
		flex-wrap: wrap;

		> .swap {
			order: 1;
		}
	}
}

//
// @include stretch-blocks(50%, middle);
//

@mixin stretch-blocks($width: 50%, $valign: top) {
	display: table;
	table-layout: fixed;

	.stretch-wrap {
		display: table-row;
	}

	.stretch-col {
		display: table-cell;
		vertical-align: $valign;
		width: $width;
	}
}

//
// @include multiline-ellipsis(1.2, 2, black);
//

@mixin multiline-ellipsis($lineh: 1.2em, $lines: 3, $bg: white) {
	position: relative;
	overflow: hidden;
	text-overflow: ellipsis;
	text-align: justify;
	margin-right: -1em;
	padding-right: 1em;
	line-height: $lineh;
	max-height: $lineh * $lines;

	&:before {
		content: '...';
		position: absolute;
		right: 0;
		bottom: 0;
	}

	&:after {
		content: '';
		position: absolute;
		right: 0;
		width: 1em;
		height: 1em;
		margin-top: .2em;
		background: $bg;
	}
}

//
// @include attr(href);
//

@mixin attr($attr) {
	content: attr($attr);
}

//
// @include counter(list, section);
//

@mixin counter($children, $name, $txt) {
	@extend %listreset;

	counter-reset: $name;

	.#{$children} {
		position: relative;

		&:before {
			counter-increment: $name;
			content: counter($name) $txt;
		}
	}
}

//
// @include calc(height, 100px, vh);
//

@mixin calc($property: width, $size: 0, $val: '%') {
	$property: calc(100 + $val - $size);
}

//
//@include pseudo();
//

@mixin pseudo($content: '', $pos: absolute, $display: block) {
	content: '#{$content}';
    display: $display;
    position: $pos;
}

/*--------------------------------
	Responsive ratio
	Used for creating scalable elements that maintain the same ratio
	example:
	.element {
		@include responsive-ratio(400, 300);
	}
*/

@mixin responsive-ratio($x, $y, $pseudo: false) {
	$padding: unquote( ( $y / $x ) * 100 + '%' );

	@if $pseudo {
		&:before {
			@include pseudo($pos: relative);

			width: 100%;
			padding-top: $padding;
		}
	} @else {
		padding-top: $padding;
	}
}

//
// @include cubic(.1, .7, 1.0, .1)
//

@mixin cubic($x: .3, $y: .6, $a: .3, $b: .3) {
	transition-timing-function: cubic-bezier($x, $y, $a, $b);
}

@mixin unselectable {
	-webkit-touch-callout: none;
	user-select: none;
}

@mixin selection {
	::-moz-selection { @content; }
	::selection { @content; }
}

@mixin hardware($backface: true, $perspective: 1000) {

	@if $backface {
		backface-visibility: hidden;
	}

	perspective: $perspective;
}

@mixin appearance($val: none) {
	-webkit-appearance: $val;
	-moz-appearance: $val;
	appearance: $val;
}

//
//@include icomoon(/0900);
//

@mixin icomoon($content: false) {
	@if $content {
		content: '#{$content}';
	}

	display: block;
	font-family: "icomoon" !important;
	font-style: normal !important;
	font-weight: normal !important;
	font-variant: normal !important;
	text-transform: none !important;
	speak: none;
	line-height: 1;
	-webkit-font-smoothing: antialiased;
	-moz-osx-font-smoothing: grayscale;
}

//
// @include z-i(absolute, 9999);
//

@mixin z-i($pos: relative, $count: 999) {
	position: $pos;
	z-index: $count;
}

// div {
//    @include absolute(100px, 100px, auto, auto);
// }

@mixin absolute($top: 0, $right: 0, $bottom: 0, $left: 0) {
   position: absolute;
   top: $top;
   right: $right;
   bottom: $bottom;
   left: $left;
}

//
// @include flex(center, justify-content);
//

@mixin flex($align: center, $justify: center) {
	display: flex;
	flex-wrap: wrap;
	align-items: $align;
	justify-content: $justify;
}

//
// @include bg(contain);
//

@mixin bg($size: cover, $pos: 50% 50%) {
	background-repeat: no-repeat;
	background-position: $pos;
	background-size: $size;
}

//
//include AFS(20px, 5, 480, 768);
//

// font-size: calc([minimum size] + ([maximum size] - [minimum size]) *
	// ((100vw - [minimum viewport width]) / ([maximum viewport width] - [minimum viewport width])));

// @mixin AFS($minS: 16px, $maxS: 6, $minWidth: 320, $maxWidth: 680) {
// 	font-size: calc($minS + $maxS * ((100vw - $minWidth + 'px') / $maxWidth));
// }

// @mixin FFS($minS: 16px, $maxS: 6, $minWidth: 320, $maxWidth: 680) {
// 	font-size: calc($minS + ($maxS - $minS) * ((100vw - $minWidth + 'px') / ($maxWidth - $minWidth)));
// }

//
// @include column(3);
//

@mixin column($count: 2, $gap: 20px) {
    column-count: $count;
    column-gap: $gap;
}

// @include keyframes(slide-down) {
//   0% { opacity: 1; }
//   90% { opacity: 0; }
// }

// .element {
//   width: 100px;
//   height: 100px;
//   background: black;
//   @include animation('slide-down 5s 3');
// }

@mixin keyframes($animation-name) {
    @-webkit-keyframes #{$animation-name} {
        @content;
    }
    @-moz-keyframes #{$animation-name} {
        @content;
    }
    @-ms-keyframes #{$animation-name} {
        @content;
    }
    @-o-keyframes #{$animation-name} {
        @content;
    }
    @keyframes #{$animation-name} {
        @content;
    }
}

@mixin animation($str) {
  -webkit-animation: #{$str};
  -moz-animation: #{$str};
  -ms-animation: #{$str};
  -o-animation: #{$str};
  animation: #{$str};
}

// @each $name in 'save' 'cancel' 'help' {
//     .icon-#{$name} {
        // background-image: url('/images/#{$name}.png');
//     }
// }

// .icon-save {
//   background-image: url("/images/save.png");
// }
// .icon-cancel {
//   background-image: url("/images/cancel.png");
// }
// .icon-help {
//   background-image: url("/images/help.png");
// }

// @include icon-colors('icon-',
//     'save'   green,
//     'cancel' gray,
//     'delete' red
// );

@mixin icon-colors($prefix, $colors...) {
    @each $i in $colors {
        .#{$prefix}#{nth($i, 1)} {
            color: nth($i, 2);
        }
    }
}

// .icon-save {
//   color: green;
// }
// .icon-cancel {
//   color: gray;
// }
// .icon-delete {
//   color: red;
// }

@mixin img_fit() {
    width: 100%;
    height: 100%;
    max-width: initial;
    object-fit: cover;
    object-position: center;
}
